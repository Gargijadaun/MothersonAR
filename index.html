<!DOCTYPE html>
<!--
Copyright 2018 The Immersive Web Community Group
Licensed under the MIT License.
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AR Video Playback</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      header {
        position: absolute;
        top: 0;
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 10px;
        text-align: center;
        z-index: 10;
      }
      button {
        padding: 10px;
        font-size: 16px;
        cursor: pointer;
      }
      #video-controls {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #video-controls button {
        margin: 0 5px;
        background: #0af;
        color: white;
        border: none;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <header>
      <button id="start-ar">START AR</button>
    </header>
    <div id="video-controls">
      <button onclick="changeVideo(1)">Video 1</button>
      <button onclick="changeVideo(2)">Video 2</button>
      <button onclick="changeVideo(3)">Video 3</button>
      <button onclick="changeVideo(4)">Video 4</button>
      <button onclick="changeVideo(5)">Video 5</button>
    </div>
    <script type="module">
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {VideoNode} from './js/render/nodes/video.js';
      import {vec3, mat4} from './js/render/math/gl-matrix.js';

      // XR globals
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.clear = false; // Transparent background for AR

      // Video element
      let video = document.createElement('video');
      video.src = './media/video/Video1.mp4'; // Default video
      video.loop = true;
      video.muted = false; // Sound enabled (requires user interaction)
      video.onerror = () => console.error('Video failed to load:', video.src);
      video.oncanplay = () => console.log('Video ready to play:', video.src);
      let videoNode = null;

      // Reticle for hit-test visualization (simple quad)
      let reticle = new Node();
      reticle.visible = false;
      scene.addNode(reticle);

      // Simple reticle geometry (small quad)
      {
        let vertices = new Float32Array([
          -0.05, -0.05, 0, 0, 0,
          0.05, -0.05, 0, 1, 0,
          0.05, 0.05, 0, 1, 1,
          -0.05, 0.05, 0, 0, 1
        ]);
        let indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
        reticle.onRendererChanged = (renderer) => {
          let vertexBuffer = renderer.createRenderBuffer(WebGLRenderingContext.ARRAY_BUFFER, vertices);
          let indexBuffer = renderer.createRenderBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, indices);
          let attribs = [
            new PrimitiveAttribute('POSITION', vertexBuffer, 3, WebGLRenderingContext.FLOAT, 20, 0),
            new PrimitiveAttribute('TEXCOORD_0', vertexBuffer, 2, WebGLRenderingContext.FLOAT, 20, 12),
          ];
          let primitive = new Primitive(attribs, indices.length);
          primitive.setIndexBuffer(indexBuffer);
          let material = new VideoMaterial(); // Reuse VideoMaterial
          material.image.texture = renderer.createTexture({ source: createReticleTexture() });
          let renderPrimitive = renderer.createRenderPrimitive(primitive, material);
          reticle.addRenderPrimitive(renderPrimitive);
        };

        function createReticleTexture() {
          let canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          let ctx = canvas.getContext('2d');
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(32, 32, 30, 0, 2 * Math.PI);
          ctx.fill();
          return canvas;
        }
      }

      function initXR() {
        xrButton = {
          domElement: document.getElementById('start-ar'),
          enabled: false,
          setSession: (session) => {
            xrButton.domElement.textContent = session ? 'EXIT AR' : 'START AR';
            xrButton.domElement.style.display = session ? 'none' : 'block';
          }
        };
        xrButton.domElement.onclick = () => {
          if (xrButton.domElement.textContent === 'START AR') {
            onRequestSession();
          } else {
            onEndSession();
          }
        };

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
            xrButton.domElement.disabled = !supported;
            xrButton.domElement.textContent = supported ? 'START AR' : 'AR NOT FOUND';
          });
        } else {
          console.error('WebXR not supported');
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']})
          .then((session) => {
            xrButton.setSession(session);
            onSessionStarted(session);
          })
          .catch((err) => console.error('Failed to start AR session:', err));
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          gl = createWebGLContext({ xrCompatible: true });
          renderer = new Renderer(gl);
          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          }).catch((err) => console.error('Failed to create hit test source:', err));
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        }).catch((err) => console.error('Failed to get local reference space:', err));
      }

      function onEndSession() {
        if (xrHitTestSource) {
          xrHitTestSource.cancel();
          xrHitTestSource = null;
        }
        xrButton.setSession(null);
        video.pause();
        document.getElementById('video-controls').style.display = 'none';
      }

      function onSessionEnded() {
        xrButton.setSession(null);
        video.pause();
        document.getElementById('video-controls').style.display = 'none';
      }

      function onSelect() {
        if (reticle.visible && !videoNode) {
          // Create a VideoNode with the current video element
          videoNode = new VideoNode({ video: video, displayMode: 'mono' });
          videoNode.visible = true;

          // Start with reticle's matrix
          let matrix = mat4.clone(reticle.matrix);

          // Translate farther along the surface normal (z-axis in local space)
          let distance = 2.0; // 2 meters away
          let translation = mat4.create();
          mat4.fromTranslation(translation, [0, 0, -distance]);
          mat4.multiply(matrix, matrix, translation);

          videoNode.matrix = matrix;

          // Scale the video to be smaller
          let aspect = videoNode.aspectRatio;
          let size = 0.1; // 0.1 meters tall
          vec3.set(videoNode.scale, aspect * size, size, 1.0);

          scene.addNode(videoNode);
          // Wait for video to be ready before playing
          if (video.readyState >= 2) { // HAVE_ENOUGH_DATA
            video.play().catch((err) => console.error('Video playback failed:', err));
          } else {
            video.oncanplay = () => {
              video.play().catch((err) => console.error('Video playback failed:', err));
            };
          }
          document.getElementById('video-controls').style.display = 'flex';
          console.log('Video placed, controls shown');
        }
      }

      function changeVideo(index) {
        const videoSources = [
          './media/video/Video1.mp4',
          './media/video/Video2.mp4',
          './media/video/Video3.mp4',
          './media/video/Video4.mp4',
          './media/video/Video5.mp4'
        ];
        const newSrc = videoSources[index - 1];
        if (video.src !== newSrc) {
          console.log('Switching to video:', newSrc);
          video.pause();
          video.src = newSrc;
          video.load();
          if (videoNode) {
            // Update existing VideoNode
            videoNode._video = video;
            videoNode._video_texture = new VideoTexture(video);
            videoNode.onRendererChanged(renderer);
            video.oncanplay = () => {
              video.play().catch((err) => console.error('Video playback failed:', err));
            };
          }
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        reticle.visible = false;

        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
            if (!videoNode) {
              document.getElementById('video-controls').style.display = 'flex';
            }
          } else {
            document.getElementById('video-controls').style.display = 'none';
          }
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      // Start the XR application
      initXR();
    </script>
  </body>
</html>